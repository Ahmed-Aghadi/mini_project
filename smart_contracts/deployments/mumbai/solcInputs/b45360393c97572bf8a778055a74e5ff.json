{
  "language": "Solidity",
  "sources": {
    "lib/chainlink-brownie-contracts/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "lib/chainlink-brownie-contracts/contracts/src/v0.8/interfaces/AutomationCompatibleInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AutomationCompatibleInterface {\n  /**\n   * @notice method that is simulated by the keepers to see if any work actually\n   * needs to be performed. This method does does not actually need to be\n   * executable, and since it is only ever simulated it can consume lots of gas.\n   * @dev To ensure that it is never called, you may want to add the\n   * cannotExecute modifier from KeeperBase to your implementation of this\n   * method.\n   * @param checkData specified in the upkeep registration so it is always the\n   * same for a registered upkeep. This can easily be broken down into specific\n   * arguments using `abi.decode`, so multiple upkeeps can be registered on the\n   * same contract and easily differentiated by the contract.\n   * @return upkeepNeeded boolean to indicate whether the keeper should call\n   * performUpkeep or not.\n   * @return performData bytes that the keeper should call performUpkeep with, if\n   * upkeep is needed. If you would like to encode data to decode later, try\n   * `abi.encode`.\n   */\n  function checkUpkeep(bytes calldata checkData) external returns (bool upkeepNeeded, bytes memory performData);\n\n  /**\n   * @notice method that is actually executed by the keepers, via the registry.\n   * The data returned by the checkUpkeep simulation will be passed into\n   * this method to actually be executed.\n   * @dev The input to this method should not be trusted, and the caller of the\n   * method should not even be restricted to any single registry. Anyone should\n   * be able call it, and the input should be validated, there is no guarantee\n   * that the data passed in is the performData returned from checkUpkeep. This\n   * could happen due to malicious keepers, racing keepers, or simply a state\n   * change while the performUpkeep transaction is waiting for confirmation.\n   * Always validate the data passed in.\n   * @param performData is the data which was passed back from the checkData\n   * simulation. If it is encoded, it can easily be decoded into other types by\n   * calling `abi.decode`. This data should not be trusted, and should be\n   * validated against the contract's current state.\n   */\n  function performUpkeep(bytes calldata performData) external;\n}\n"
    },
    "lib/chainlink-brownie-contracts/contracts/src/v0.8/interfaces/AutomationRegistryInterface1_2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @notice config of the registry\n * @dev only used in params and return values\n * @member paymentPremiumPPB payment premium rate oracles receive on top of\n * being reimbursed for gas, measured in parts per billion\n * @member flatFeeMicroLink flat fee paid to oracles for performing upkeeps,\n * priced in MicroLink; can be used in conjunction with or independently of\n * paymentPremiumPPB\n * @member blockCountPerTurn number of blocks each oracle has during their turn to\n * perform upkeep before it will be the next keeper's turn to submit\n * @member checkGasLimit gas limit when checking for upkeep\n * @member stalenessSeconds number of seconds that is allowed for feed data to\n * be stale before switching to the fallback pricing\n * @member gasCeilingMultiplier multiplier to apply to the fast gas feed price\n * when calculating the payment ceiling for keepers\n * @member minUpkeepSpend minimum LINK that an upkeep must spend before cancelling\n * @member maxPerformGas max executeGas allowed for an upkeep on this registry\n * @member fallbackGasPrice gas price used if the gas price feed is stale\n * @member fallbackLinkPrice LINK price used if the LINK price feed is stale\n * @member transcoder address of the transcoder contract\n * @member registrar address of the registrar contract\n */\nstruct Config {\n  uint32 paymentPremiumPPB;\n  uint32 flatFeeMicroLink; // min 0.000001 LINK, max 4294 LINK\n  uint24 blockCountPerTurn;\n  uint32 checkGasLimit;\n  uint24 stalenessSeconds;\n  uint16 gasCeilingMultiplier;\n  uint96 minUpkeepSpend;\n  uint32 maxPerformGas;\n  uint256 fallbackGasPrice;\n  uint256 fallbackLinkPrice;\n  address transcoder;\n  address registrar;\n}\n\n/**\n * @notice state of the registry\n * @dev only used in params and return values\n * @member nonce used for ID generation\n * @member ownerLinkBalance withdrawable balance of LINK by contract owner\n * @member expectedLinkBalance the expected balance of LINK of the registry\n * @member numUpkeeps total number of upkeeps on the registry\n */\nstruct State {\n  uint32 nonce;\n  uint96 ownerLinkBalance;\n  uint256 expectedLinkBalance;\n  uint256 numUpkeeps;\n}\n\ninterface AutomationRegistryBaseInterface {\n  function registerUpkeep(\n    address target,\n    uint32 gasLimit,\n    address admin,\n    bytes calldata checkData\n  ) external returns (uint256 id);\n\n  function performUpkeep(uint256 id, bytes calldata performData) external returns (bool success);\n\n  function cancelUpkeep(uint256 id) external;\n\n  function addFunds(uint256 id, uint96 amount) external;\n\n  function setUpkeepGasLimit(uint256 id, uint32 gasLimit) external;\n\n  function getUpkeep(uint256 id)\n    external\n    view\n    returns (\n      address target,\n      uint32 executeGas,\n      bytes memory checkData,\n      uint96 balance,\n      address lastKeeper,\n      address admin,\n      uint64 maxValidBlocknumber,\n      uint96 amountSpent\n    );\n\n  function getActiveUpkeepIDs(uint256 startIndex, uint256 maxCount) external view returns (uint256[] memory);\n\n  function getKeeperInfo(address query)\n    external\n    view\n    returns (\n      address payee,\n      bool active,\n      uint96 balance\n    );\n\n  function getState()\n    external\n    view\n    returns (\n      State memory,\n      Config memory,\n      address[] memory\n    );\n}\n\n/**\n * @dev The view methods are not actually marked as view in the implementation\n * but we want them to be easily queried off-chain. Solidity will not compile\n * if we actually inherit from this interface, so we document it here.\n */\ninterface AutomationRegistryInterface is AutomationRegistryBaseInterface {\n  function checkUpkeep(uint256 upkeepId, address from)\n    external\n    view\n    returns (\n      bytes memory performData,\n      uint256 maxLinkPayment,\n      uint256 gasLimit,\n      int256 gasWei,\n      int256 linkEth\n    );\n}\n\ninterface AutomationRegistryExecutableInterface is AutomationRegistryBaseInterface {\n  function checkUpkeep(uint256 upkeepId, address from)\n    external\n    returns (\n      bytes memory performData,\n      uint256 maxLinkPayment,\n      uint256 gasLimit,\n      uint256 adjustedGasWei,\n      uint256 linkEth\n    );\n}\n"
    },
    "lib/chainlink-brownie-contracts/contracts/src/v0.8/interfaces/KeeperRegistryInterface1_2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/**\n * @notice This is a deprecated interface. Please use AutomationRegistryInterface1_2 directly.\n */\npragma solidity ^0.8.0;\nimport {Config, State} from \"./AutomationRegistryInterface1_2.sol\";\nimport {AutomationRegistryBaseInterface as KeeperRegistryBaseInterface} from \"./AutomationRegistryInterface1_2.sol\";\nimport {AutomationRegistryInterface as KeeperRegistryInterface} from \"./AutomationRegistryInterface1_2.sol\";\nimport {AutomationRegistryExecutableInterface as KeeperRegistryExecutableInterface} from \"./AutomationRegistryInterface1_2.sol\";\n"
    },
    "lib/chainlink-brownie-contracts/contracts/src/v0.8/interfaces/LinkTokenInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface LinkTokenInterface {\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n  function approve(address spender, uint256 value) external returns (bool success);\n\n  function balanceOf(address owner) external view returns (uint256 balance);\n\n  function decimals() external view returns (uint8 decimalPlaces);\n\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\n\n  function increaseApproval(address spender, uint256 subtractedValue) external;\n\n  function name() external view returns (string memory tokenName);\n\n  function symbol() external view returns (string memory tokenSymbol);\n\n  function totalSupply() external view returns (uint256 totalTokensIssued);\n\n  function transfer(address to, uint256 value) external returns (bool success);\n\n  function transferAndCall(\n    address to,\n    uint256 value,\n    bytes calldata data\n  ) external returns (bool success);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool success);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/metatx/ERC2771Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (metatx/ERC2771Context.sol)\n\npragma solidity ^0.8.9;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Context variant with ERC2771 support.\n */\nabstract contract ERC2771Context is Context {\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address private immutable _trustedForwarder;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(address trustedForwarder) {\n        _trustedForwarder = trustedForwarder;\n    }\n\n    function isTrustedForwarder(address forwarder) public view virtual returns (bool) {\n        return forwarder == _trustedForwarder;\n    }\n\n    function _msgSender() internal view virtual override returns (address sender) {\n        if (isTrustedForwarder(msg.sender)) {\n            // The assembly code is more direct than the Solidity version using `abi.decode`.\n            /// @solidity memory-safe-assembly\n            assembly {\n                sender := shr(96, calldataload(sub(calldatasize(), 20)))\n            }\n        } else {\n            return super._msgSender();\n        }\n    }\n\n    function _msgData() internal view virtual override returns (bytes calldata) {\n        if (isTrustedForwarder(msg.sender)) {\n            return msg.data[:msg.data.length - 20];\n        } else {\n            return super._msgData();\n        }\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(\n        address[] calldata accounts,\n        uint256[] calldata ids\n    ) external view returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "lib/solmate/src/tokens/ERC1155.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Minimalist and gas efficient standard ERC1155 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC1155.sol)\nabstract contract ERC1155 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event TransferSingle(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 amount\n    );\n\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] amounts\n    );\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    event URI(string value, uint256 indexed id);\n\n    /*//////////////////////////////////////////////////////////////\n                             ERC1155 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address => mapping(uint256 => uint256)) public balanceOf;\n\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    /*//////////////////////////////////////////////////////////////\n                             METADATA LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function uri(uint256 id) public view virtual returns (string memory);\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC1155 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual {\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \"NOT_AUTHORIZED\");\n\n        balanceOf[from][id] -= amount;\n        balanceOf[to][id] += amount;\n\n        emit TransferSingle(msg.sender, from, to, id, amount);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public virtual {\n        require(ids.length == amounts.length, \"LENGTH_MISMATCH\");\n\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \"NOT_AUTHORIZED\");\n\n        // Storing these outside the loop saves ~15 gas per iteration.\n        uint256 id;\n        uint256 amount;\n\n        for (uint256 i = 0; i < ids.length; ) {\n            id = ids[i];\n            amount = amounts[i];\n\n            balanceOf[from][id] -= amount;\n            balanceOf[to][id] += amount;\n\n            // An array can't have a total length\n            // larger than the max uint256 value.\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, from, ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\n        public\n        view\n        virtual\n        returns (uint256[] memory balances)\n    {\n        require(owners.length == ids.length, \"LENGTH_MISMATCH\");\n\n        balances = new uint256[](owners.length);\n\n        // Unchecked because the only math done is incrementing\n        // the array index counter which cannot possibly overflow.\n        unchecked {\n            for (uint256 i = 0; i < owners.length; ++i) {\n                balances[i] = balanceOf[owners[i]][ids[i]];\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0xd9b67a26 || // ERC165 Interface ID for ERC1155\n            interfaceId == 0x0e89341c; // ERC165 Interface ID for ERC1155MetadataURI\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        balanceOf[to][id] += amount;\n\n        emit TransferSingle(msg.sender, address(0), to, id, amount);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, address(0), id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _batchMint(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        uint256 idsLength = ids.length; // Saves MLOADs.\n\n        require(idsLength == amounts.length, \"LENGTH_MISMATCH\");\n\n        for (uint256 i = 0; i < idsLength; ) {\n            balanceOf[to][ids[i]] += amounts[i];\n\n            // An array can't have a total length\n            // larger than the max uint256 value.\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit TransferBatch(msg.sender, address(0), to, ids, amounts);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, address(0), ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _batchBurn(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        uint256 idsLength = ids.length; // Saves MLOADs.\n\n        require(idsLength == amounts.length, \"LENGTH_MISMATCH\");\n\n        for (uint256 i = 0; i < idsLength; ) {\n            balanceOf[from][ids[i]] -= amounts[i];\n\n            // An array can't have a total length\n            // larger than the max uint256 value.\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit TransferBatch(msg.sender, from, address(0), ids, amounts);\n    }\n\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        balanceOf[from][id] -= amount;\n\n        emit TransferSingle(msg.sender, from, address(0), id, amount);\n    }\n}\n\n/// @notice A generic interface for a contract which properly accepts ERC1155 tokens.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC1155.sol)\nabstract contract ERC1155TokenReceiver {\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC1155TokenReceiver.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC1155TokenReceiver.onERC1155BatchReceived.selector;\n    }\n}\n"
    },
    "lib/solmate/src/tokens/ERC721.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\nabstract contract ERC721 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /*//////////////////////////////////////////////////////////////\n                         METADATA STORAGE/LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n\n    /*//////////////////////////////////////////////////////////////\n                      ERC721 BALANCE/OWNER STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => address) internal _ownerOf;\n\n    mapping(address => uint256) internal _balanceOf;\n\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), \"NOT_MINTED\");\n    }\n\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), \"ZERO_ADDRESS\");\n\n        return _balanceOf[owner];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         ERC721 APPROVAL STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => address) public getApproved;\n\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \"NOT_AUTHORIZED\");\n\n        getApproved[id] = spender;\n\n        emit Approval(owner, spender, id);\n    }\n\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == _ownerOf[id], \"WRONG_FROM\");\n\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            \"NOT_AUTHORIZED\"\n        );\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        unchecked {\n            _balanceOf[from]--;\n\n            _balanceOf[to]++;\n        }\n\n        _ownerOf[id] = to;\n\n        delete getApproved[id];\n\n        emit Transfer(from, to, id);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(_ownerOf[id] == address(0), \"ALREADY_MINTED\");\n\n        // Counter overflow is incredibly unrealistic.\n        unchecked {\n            _balanceOf[to]++;\n        }\n\n        _ownerOf[id] = to;\n\n        emit Transfer(address(0), to, id);\n    }\n\n    function _burn(uint256 id) internal virtual {\n        address owner = _ownerOf[id];\n\n        require(owner != address(0), \"NOT_MINTED\");\n\n        // Ownership check above ensures no underflow.\n        unchecked {\n            _balanceOf[owner]--;\n        }\n\n        delete _ownerOf[id];\n\n        delete getApproved[id];\n\n        emit Transfer(owner, address(0), id);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL SAFE MINT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n}\n\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\nabstract contract ERC721TokenReceiver {\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC721TokenReceiver.onERC721Received.selector;\n    }\n}\n"
    },
    "lib/solmate/src/utils/LibString.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// @notice Efficient library for creating string representations of integers.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)\n/// @author Modified from Solady (https://github.com/Vectorized/solady/blob/main/src/utils/LibString.sol)\nlibrary LibString {\n    function toString(int256 value) internal pure returns (string memory str) {\n        if (value >= 0) return toString(uint256(value));\n\n        unchecked {\n            str = toString(uint256(-value));\n\n            /// @solidity memory-safe-assembly\n            assembly {\n                // Note: This is only safe because we over-allocate memory\n                // and write the string from right to left in toString(uint256),\n                // and thus can be sure that sub(str, 1) is an unused memory location.\n\n                let length := mload(str) // Load the string length.\n                // Put the - character at the start of the string contents.\n                mstore(str, 45) // 45 is the ASCII code for the - character.\n                str := sub(str, 1) // Move back the string pointer by a byte.\n                mstore(str, add(length, 1)) // Update the string length.\n            }\n        }\n    }\n\n    function toString(uint256 value) internal pure returns (string memory str) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but we allocate 160 bytes\n            // to keep the free memory pointer word aligned. We'll need 1 word for the length, 1 word for the\n            // trailing zeros padding, and 3 other words for a max of 78 digits. In total: 5 * 32 = 160 bytes.\n            let newFreeMemoryPointer := add(mload(0x40), 160)\n\n            // Update the free memory pointer to avoid overriding our string.\n            mstore(0x40, newFreeMemoryPointer)\n\n            // Assign str to the end of the zone of newly allocated memory.\n            str := sub(newFreeMemoryPointer, 32)\n\n            // Clean the last word of memory it may not be overwritten.\n            mstore(str, 0)\n\n            // Cache the end of the memory to calculate the length later.\n            let end := str\n\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            // prettier-ignore\n            for { let temp := value } 1 {} {\n                // Move the pointer 1 byte to the left.\n                str := sub(str, 1)\n\n                // Write the character to the pointer.\n                // The ASCII index of the '0' character is 48.\n                mstore8(str, add(48, mod(temp, 10)))\n\n                // Keep dividing temp until zero.\n                temp := div(temp, 10)\n\n                 // prettier-ignore\n                if iszero(temp) { break }\n            }\n\n            // Compute and cache the final total length of the string.\n            let length := sub(end, str)\n\n            // Move the pointer 32 bytes leftwards to make room for the length.\n            str := sub(str, 32)\n\n            // Store the string's length at the start of memory allocated for our string.\n            mstore(str, length)\n        }\n    }\n}\n"
    },
    "src/Marketplace.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\nimport {ERC1155TokenReceiver} from \"solmate/tokens/ERC1155.sol\";\nimport \"openzeppelin/token/ERC1155/IERC1155.sol\";\nimport {ERC721TokenReceiver} from \"solmate/tokens/ERC721.sol\";\nimport \"openzeppelin/token/ERC721/IERC721.sol\";\nimport \"solmate/utils/LibString.sol\";\nimport \"chainlink/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport {KeeperRegistryInterface, State, Config} from \"chainlink/v0.8/interfaces/KeeperRegistryInterface1_2.sol\";\nimport {LinkTokenInterface} from \"chainlink/v0.8/interfaces/LinkTokenInterface.sol\";\nimport \"chainlink/v0.8/interfaces/AutomationCompatibleInterface.sol\";\nimport \"openzeppelin/metatx/ERC2771Context.sol\";\n\ninterface KeeperRegistrarInterface {\n    function register(\n        string memory name,\n        bytes calldata encryptedEmail,\n        address upkeepContract,\n        uint32 gasLimit,\n        address adminAddress,\n        bytes calldata checkData,\n        uint96 amount,\n        uint8 source,\n        address sender\n    ) external;\n}\n\ncontract Marketplace is ERC2771Context {\n    error USDNotSupported();\n    error AuctioNotSupported();\n    error InvalidTokenId();\n    error InvalidListingId();\n    error InvalidListing();\n    error ValidListing();\n    error InvalidPrice();\n    error NotTokenOwner();\n    error NotListingOwner();\n    error NotEnoughFunds();\n    error NotAuction();\n    error NoBids();\n    error BidNotHighEnough();\n    error AuctionNotOver();\n    error AuctionOver();\n    error USDNotSupportedForAuction();\n    error AuctionCantBeBought();\n    error NotHighestBidder();\n    struct Listing {\n        address seller;\n        bool inUSD;\n        uint256 tokenId;\n        uint256 price;\n        uint256 timestamp;\n        bool isValid;\n        bool isAuction;\n        uint256 aucionTime;\n    }\n    struct Bid {\n        address bidder;\n        uint256 amount;\n    }\n    AggregatorV3Interface public immutable eth_usd_priceFeed;\n    IERC721 internal map;\n    IERC1155 internal utils;\n    uint public listingCount = 0;\n\n    mapping(uint256 => Listing) public listings;\n    mapping(address => uint256) public balances;\n    mapping(uint256 => Bid) public highestBid;\n    mapping(address => uint256) public auctionBalance;\n    mapping(uint256 => uint256) public listingToUpkeepID;\n\n    LinkTokenInterface public immutable i_link;\n    address public immutable registrar;\n    KeeperRegistryInterface public immutable i_registry;\n    bytes4 registerSig = KeeperRegistrarInterface.register.selector;\n\n    uint256 public gasLimit;\n\n    constructor(\n        address eth_usd_priceFeedAddress,\n        address mapAddress,\n        address utilsAddress,\n        address _linkAddress,\n        address _registrar,\n        address _registryAddress,\n        uint256 _gasLimit,\n        address trustedForwarder\n    ) ERC2771Context(trustedForwarder) {\n        eth_usd_priceFeed = AggregatorV3Interface(eth_usd_priceFeedAddress);\n        map = IERC721(mapAddress);\n        utils = IERC1155(utilsAddress);\n        i_link = LinkTokenInterface(_linkAddress);\n        registrar = _registrar;\n        i_registry = KeeperRegistryInterface(_registryAddress);\n        gasLimit = _gasLimit;\n    }\n\n    function registerAndPredictID(uint256 listingId, uint96 amount) private {\n        i_link.transferFrom(_msgSender(), address(this), amount);\n        (State memory state, , ) = i_registry.getState();\n        uint256 oldNonce = state.nonce;\n        bytes memory checkData = abi.encodePacked(listingId);\n        bytes memory payload = abi.encode(\n            LibString.toString(listingId),\n            \"0x\",\n            address(this),\n            gasLimit,\n            address(_msgSender()),\n            checkData,\n            amount,\n            0,\n            address(this)\n        );\n\n        i_link.transferAndCall(\n            registrar,\n            amount,\n            bytes.concat(registerSig, payload)\n        );\n        (state, , ) = i_registry.getState();\n        uint256 newNonce = state.nonce;\n        if (newNonce == oldNonce + 1) {\n            uint256 upkeepID = uint256(\n                keccak256(\n                    abi.encodePacked(\n                        blockhash(block.number - 1),\n                        address(i_registry),\n                        uint32(oldNonce)\n                    )\n                )\n            );\n            // DEV - Use the upkeepID however you see fit\n            listingToUpkeepID[listingId] = upkeepID;\n        } else {\n            revert(\"auto-approve disabled\");\n        }\n    }\n\n    function checkUpkeep(\n        bytes calldata checkData\n    ) external view returns (bool upkeepNeeded, bytes memory performData) {\n        uint256 listingId = abi.decode(checkData, (uint256));\n\n        upkeepNeeded =\n            (block.timestamp >\n                listings[listingId].timestamp +\n                    listings[listingId].aucionTime) &&\n            highestBid[listingId].bidder != address(0) &&\n            (listings[listingId].isValid || highestBid[listingId].amount > 0);\n        performData = checkData;\n    }\n\n    function performUpkeep(bytes calldata performData) external {\n        uint256 listingId = abi.decode(performData, (uint256));\n\n        calculateWinner(listingId);\n    }\n\n    /*\n     * @dev If isAuction is true, the price is the minimum bid\n     * @dev auctionTime is the time in seconds for which the auction will run, so timestamp + auctionTime is the end time\n     * @dev If isAuction is false, the price is the fixed price and auctionTime is ignored\n     * @dev For auction, isUSD should be false\n     * @dev if isAuction is true, the amount is the amount of LINK to be transferred to the upkeep contract else it is ignored\n     */\n    function createListing(\n        bool inUSD,\n        uint256 tokenId,\n        uint256 price,\n        bool isAuction,\n        uint256 auctionTime,\n        uint96 amount\n    ) public {\n        if (price <= 0) revert InvalidPrice();\n        if (tokenId <= 0) revert InvalidTokenId();\n        if (map.ownerOf(tokenId) != _msgSender()) revert NotTokenOwner();\n        if (isAuction && inUSD) revert USDNotSupportedForAuction();\n        if (inUSD && address(eth_usd_priceFeed) == address(0))\n            revert USDNotSupported();\n        if (isAuction && address(i_link) == address(0))\n            revert AuctioNotSupported();\n        listingCount++;\n        listings[listingCount] = Listing(\n            _msgSender(),\n            inUSD,\n            tokenId,\n            price,\n            block.timestamp,\n            true,\n            isAuction,\n            auctionTime\n        );\n        if (isAuction) {\n            registerAndPredictID(listingCount, amount);\n        }\n    }\n\n    function deleteListing(uint listingId) public {\n        if (isListingValid(listingId) == false) revert InvalidListing();\n        if (map.ownerOf(listings[listingId].tokenId) != _msgSender())\n            revert NotListingOwner();\n        listings[listingId].isValid = false;\n    }\n\n    function buyListing(uint listingId) public payable {\n        if (isListingValid(listingId) == false) revert InvalidListing();\n        if (listings[listingId].isAuction) revert AuctionCantBeBought();\n        uint price = getPrice(listingId);\n        if (msg.value < price) revert NotEnoughFunds();\n        uint excess = msg.value - price;\n        if (excess > 0) {\n            balances[_msgSender()] += excess;\n        }\n        balances[listings[listingId].seller] += price;\n        map.safeTransferFrom(\n            listings[listingId].seller,\n            _msgSender(),\n            listings[listingId].tokenId\n        );\n        listings[listingId].isValid = false;\n    }\n\n    function bid(uint listingId) public payable {\n        if (listings[listingId].isValid == false) revert InvalidListing();\n        if (listings[listingId].isAuction == false) revert NotAuction();\n        if (msg.value < listings[listingId].price) revert BidNotHighEnough();\n        if (msg.value <= highestBid[listingId].amount)\n            revert BidNotHighEnough();\n        if (highestBid[listingId].amount > 0) {\n            balances[highestBid[listingId].bidder] += highestBid[listingId]\n                .amount;\n            auctionBalance[highestBid[listingId].bidder] -= highestBid[\n                listingId\n            ].amount;\n        }\n        auctionBalance[_msgSender()] += msg.value;\n        highestBid[listingId] = Bid(_msgSender(), msg.value);\n    }\n\n    /*\n     * @dev If the auction is over and the seller is approved for all, the highest bidder will get the token\n     * @dev If the auction is over and the seller is not approved for all, the highest bidder can withdraw the funds\n     * @dev If the auction is over and the seller have deleted the listing, the highest bidder can withdraw the funds\n     */\n    function calculateWinner(uint listingId) public {\n        if (listings[listingId].isAuction == false) revert NotAuction();\n        if (\n            block.timestamp <=\n            listings[listingId].timestamp + listings[listingId].aucionTime\n        ) revert AuctionNotOver();\n        if (highestBid[listingId].bidder == address(0)) revert NoBids();\n        if (listings[listingId].isValid == false) {\n            if (highestBid[listingId].amount > 0) {\n                _invalidateAuctionBid(listingId);\n            } else {\n                revert InvalidListing();\n            }\n        }\n\n        if (highestBid[listingId].amount <= 0) {\n            listings[listingId].isValid = false;\n            return;\n        }\n        if (\n            map.isApprovedForAll(listings[listingId].seller, address(this)) ==\n            false\n        ) {\n            _invalidateAuctionBid(listingId);\n            listings[listingId].isValid = false;\n        } else {\n            if (listings[listingId].isValid == false) revert InvalidListing();\n            balances[listings[listingId].seller] += highestBid[listingId]\n                .amount;\n            // not safe transfer from because calculate winner will be called by automation and it shouldn't revert\n            map.transferFrom(\n                listings[listingId].seller,\n                highestBid[listingId].bidder,\n                listings[listingId].tokenId\n            );\n            listings[listingId].isValid = false;\n        }\n    }\n\n    /*\n     * @dev If the auction is over but the seller is not approved for all or seller have deleted the listing, the highest bidder can withdraw the funds\n     * @dev If the auction is not over but seller have deleted the listing, the highest bidder can withdraw the funds\n     */\n    function invalidateAuctionBid(uint listingId) public {\n        if (listings[listingId].isAuction == false) revert NotAuction();\n        if (\n            block.timestamp <=\n            listings[listingId].timestamp + listings[listingId].aucionTime\n        ) {\n            if (listings[listingId].isValid) {\n                revert ValidListing();\n            } else {\n                revert AuctionNotOver();\n            }\n        } else {\n            if (\n                map.isApprovedForAll(listings[listingId].seller, address(this))\n            ) {\n                if (listings[listingId].isValid) {\n                    revert ValidListing();\n                }\n            }\n        }\n        if (highestBid[listingId].amount <= 0) revert NotEnoughFunds();\n        _invalidateAuctionBid(listingId);\n    }\n\n    function _invalidateAuctionBid(uint listingId) private {\n        auctionBalance[highestBid[listingId].bidder] -= highestBid[listingId]\n            .amount;\n        balances[highestBid[listingId].bidder] += highestBid[listingId].amount;\n        highestBid[listingId].amount = 0;\n    }\n\n    function withdraw() public {\n        uint amount = balances[_msgSender()];\n        if (amount <= 0) revert NotEnoughFunds();\n        balances[_msgSender()] = 0;\n        payable(_msgSender()).transfer(amount);\n    }\n\n    /*\n     * @dev Returns the price of a listing in ETH\n     */\n    function getPrice(uint listingId) public view returns (uint256) {\n        if (listingId <= 0 || listingId > listingCount)\n            revert InvalidListingId();\n        if (listings[listingId].inUSD) {\n            uint decimals = eth_usd_priceFeed.decimals();\n            (\n                ,\n                /* uint80 roundID */ int answer /*uint startedAt*/ /*uint timeStamp*/ /*uint80 answeredInRound*/,\n                ,\n                ,\n\n            ) = eth_usd_priceFeed.latestRoundData();\n            uint256 priceInEth = (listings[listingId].price *\n                10 ** (decimals)) / uint(answer);\n            return priceInEth;\n        } else {\n            return listings[listingId].price;\n        }\n    }\n\n    function isListingValid(uint listingId) public view returns (bool) {\n        if (listingId <= 0 || listingId > listingCount)\n            revert InvalidListingId();\n        if (\n            map.ownerOf(listings[listingId].tokenId) !=\n            listings[listingId].seller\n        ) {\n            return false;\n        }\n        return listings[listingId].isValid;\n    }\n\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes memory\n    ) public virtual returns (bytes4) {\n        return ERC1155TokenReceiver.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    ) public virtual returns (bytes4) {\n        return ERC1155TokenReceiver.onERC1155BatchReceived.selector;\n    }\n\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC721TokenReceiver.onERC721Received.selector;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "remappings": [
      "chainlink-brownie-contracts/=lib/chainlink-brownie-contracts/",
      "chainlink/=lib/chainlink-brownie-contracts/contracts/src/",
      "ds-test/=lib/forge-std/lib/ds-test/src/",
      "erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/",
      "forge-std/=lib/forge-std/src/",
      "openzeppelin-contracts/=lib/openzeppelin-contracts/",
      "openzeppelin/=lib/openzeppelin-contracts/contracts/",
      "solmate/=lib/solmate/src/"
    ]
  }
}